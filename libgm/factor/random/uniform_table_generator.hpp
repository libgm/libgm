#ifndef LIBGM_UNIFORM_TABLE_GENERATOR_HPP
#define LIBGM_UNIFORM_TABLE_GENERATOR_HPP

#include <algorithm>
#include <functional>
#include <iostream>
#include <random>

namespace libgm {

  /**
   * A class for generating table-like factors whose parameters are filled
   * uniformly (either in log-space or in the probability space, depending
   * on the factor type).
   *
   * Marginal factors are generated by assigning to each parameter
   * a random value drawn from Uniform[lower, upper].
   * Conditional factors are generated by first generating a marginal
   * factor and then computing the conditional using standard factor
   * operations.
   *
   * \tparam F the generated factor type
   *
   * \see RandomFactorGenerator
   * \ingroup factor_random
   */
  template <typename F>
  class uniform_table_generator {
  public:
    // The real type of the factor
    typedef typename F::real_type real_type;

    // RandomFactorGenerator typedefs
    typedef typename F::domain_type domain_type;
    typedef F result_type;

    struct param_type {
      real_type lower;
      real_type upper;

      param_type(real_type lower = real_type(0),
                 real_type upper = real_type(1))
        : lower(lower), upper(upper) {
        check();
      }

      void check() const {
        assert(lower <= upper);
      }

      friend std::ostream& operator<<(std::ostream& out, const param_type& p) {
        out << p.lower << " " << p.upper;
        return out;
      }
    }; // struct param_type

    //! Constructs a generator of factors filled uniformly within limits
    explicit uniform_table_generator(real_type lower = real_type(0),
                                     real_type upper = real_type(1))
      : param_(lower, upper) { }

    //! Constructs generator with the given parameters
    explicit uniform_table_generator(const param_type& param)
      : param_(param) { param.check(); }

    //! Generate a marginal distribution p(args) using the stored parameters.
    template <typename RandomNumberGenerator>
    F operator()(const domain_type& args,
                 RandomNumberGenerator& rng) const {
      std::uniform_real_distribution<real_type> unif(param_.lower, param_.upper);
      F f(args);
      std::generate(f.begin(), f.end(), std::bind(unif, std::ref(rng)));
      return f;
    }

    //! Generates a conditional distribution p(head | tail) using the stored
    //! parameters. Implemented by conditiong a random marginal distribution.
    template <typename RandomNumberGenerator>
    F operator()(const domain_type& head,
                 const domain_type& tail,
                 RandomNumberGenerator& rng) const {
      assert(disjoint(head, tail));
      return operator()(head + tail, rng).conditional(tail);
    }

    //! Returns the parameter set associated with this generator
    const param_type& param() const {
      return param_;
    }

    //! Sets the parameter set associated with this generator
    void param(const param_type& param) {
      param_.check();
      param_ = param;
    }

  private:
    param_type param_;

  }; // class uniform_table_generator

  /**
   * Prints the parameters of the generator to an output stream.
   * \relates uniform_table_generator
   */
  template <typename F>
  std::ostream&
  operator<<(std::ostream& out, const uniform_table_generator<F>& gen) {
    out << gen.param();
    return out;
  }

} // namespace libgm

#endif
